/**\n * EXEMPLO DE INTEGRAÇÃO - Como usar o sistema modular\n * \n * Este arquivo mostra como integrar o novo sistema modular\n * com o server.js existente de forma gradual e segura.\n */\n\n// ===============================================\n// 1. IMPORTS NO INÍCIO DO server.js\n// ===============================================\n\n// Configuração centralizada\nconst appConfig = require('./src/config/app.config');\n\n// Sistema de logging robusto\nconst { \n    createLogger, \n    httpLoggingMiddleware, \n    authLogger, \n    systemLogger \n} = require('./src/utils/logger');\n\n// Middleware de segurança\nconst { \n    sanitizeMiddleware, \n    handleValidationErrors,\n    validators,\n    createSmartRateLimit,\n    bodySizeLimit \n} = require('./src/middleware/validation.middleware');\n\n// Sistema de autenticação\nconst { \n    authenticateToken, \n    requireRole, \n    requireAdmin, \n    requireUser,\n    generateToken,\n    invalidateToken \n} = require('./src/middleware/auth.middleware');\n\n// Rotas modulares\nconst authRoutes = require('./src/routes/auth.routes');\n\n// Controllers\nconst authController = require('./src/controllers/auth.controller');\n\n// ===============================================\n// 2. CONFIGURAÇÃO INICIAL\n// ===============================================\n\n// Criar logger principal\nconst logger = createLogger('server');\n\n// Log de inicialização\nlogger.info('Starting Editaliza server', {\n    environment: appConfig.environment.NODE_ENV,\n    port: appConfig.environment.PORT,\n    features: Object.keys(appConfig.features).filter(f => appConfig.features[f])\n});\n\n// ===============================================\n// 3. MIDDLEWARES (ordem importa!)\n// ===============================================\n\n// Middleware de logging HTTP (primeiro)\napp.use(httpLoggingMiddleware());\n\n// Rate limiting inteligente\napp.use(createSmartRateLimit({\n    windowMs: 15 * 60 * 1000, // 15 min\n    max: appConfig.rateLimit.global.max,\n    message: 'Muitas requisições. Tente novamente em 15 minutos.'\n}));\n\n// Sanitização de entrada\napp.use(sanitizeMiddleware);\n\n// Limite de tamanho do body\napp.use(bodySizeLimit('10mb'));\n\n// Middlewares existentes (manter ordem)\napp.use(helmet(/* configuração existente */));\napp.use(cors(/* configuração existente */));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// ===============================================\n// 4. ROTAS MODULARES (novas)\n// ===============================================\n\n// Usar as novas rotas de autenticação\napp.use('/api/auth', authRoutes);\n\n// ===============================================\n// 5. ROTAS EXISTENTES (mantidas por compatibilidade)\n// ===============================================\n\n// Exemplo de migração gradual - manter rotas antigas funcionando\napp.post('/api/login', (req, res) => {\n    logger.warn('Deprecated route used', {\n        route: '/api/login',\n        ip: req.ip,\n        message: 'Use /api/auth/login instead'\n    });\n    \n    // Redirecionar para nova rota OU processar aqui\n    authController.login(req, res);\n});\n\n// ===============================================\n// 6. EXEMPLOS DE USO DO MIDDLEWARE DE AUTH\n// ===============================================\n\n// Rota protegida simples\napp.get('/api/profile', authenticateToken(), async (req, res) => {\n    const logger = createLogger('profile').child({ userId: req.user.id });\n    \n    try {\n        logger.info('Profile access', { userId: req.user.id });\n        \n        // Sua lógica existente aqui\n        res.json({\n            success: true,\n            user: req.user\n        });\n        \n    } catch (error) {\n        logger.error('Profile fetch error', { error: error.message });\n        res.status(500).json({ error: 'Erro interno' });\n    }\n});\n\n// Rota apenas para admin\napp.get('/api/admin/users', requireAdmin, async (req, res) => {\n    const logger = createLogger('admin').child({ adminId: req.user.id });\n    \n    try {\n        logger.info('Admin users list accessed');\n        \n        // Lógica de admin aqui\n        res.json({ users: [] });\n        \n    } catch (error) {\n        logger.error('Admin operation error', { error: error.message });\n        res.status(500).json({ error: 'Erro interno' });\n    }\n});\n\n// Rota com validação robusta\napp.post('/api/plans', \n    authenticateToken(), // Auth required\n    [\n        validators.text('name', { minLength: 3, maxLength: 100 }),\n        validators.date('exam_date', { allowPast: false }),\n        validators.integer('study_hours_per_day', 1, 12)\n    ],\n    handleValidationErrors, // Processar erros\n    async (req, res) => {\n        const logger = createLogger('plans').child({ \n            userId: req.user.id,\n            requestId: req.logger.context.requestId\n        });\n        \n        try {\n            // req.validatedData contém dados validados e sanitizados\n            const { name, exam_date, study_hours_per_day } = req.validatedData;\n            \n            logger.info('Creating new study plan', { name, exam_date });\n            \n            // Sua lógica de criação de plano aqui\n            const newPlan = {\n                id: Date.now(),\n                name,\n                exam_date,\n                study_hours_per_day,\n                user_id: req.user.id,\n                created_at: new Date()\n            };\n            \n            res.status(201).json({\n                success: true,\n                plan: newPlan\n            });\n            \n        } catch (error) {\n            logger.error('Plan creation error', { \n                error: error.message,\n                stack: error.stack\n            });\n            res.status(500).json({ error: 'Erro ao criar plano' });\n        }\n    }\n);\n\n// ===============================================\n// 7. RATE LIMITING ESPECÍFICO\n// ===============================================\n\n// Rate limit rigoroso para operações críticas\nconst criticalRateLimit = createSmartRateLimit({\n    windowMs: 5 * 60 * 1000, // 5 min\n    max: 3, // apenas 3 tentativas\n    message: 'Muitas tentativas. Aguarde 5 minutos.'\n});\n\napp.post('/api/admin/delete-user', \n    requireAdmin,\n    criticalRateLimit,\n    async (req, res) => {\n        // Operação crítica com rate limit rigoroso\n    }\n);\n\n// ===============================================\n// 8. HEALTH CHECKS\n// ===============================================\n\napp.get('/health', (req, res) => {\n    try {\n        const health = {\n            status: 'healthy',\n            timestamp: new Date().toISOString(),\n            uptime: process.uptime(),\n            memory: process.memoryUsage(),\n            version: process.env.npm_package_version || '1.0.0',\n            environment: appConfig.environment.NODE_ENV,\n            \n            // Verificações específicas\n            services: {\n                database: 'connected', // Verificar conexão DB\n                redis: appConfig.database.redis.enabled ? 'connected' : 'disabled',\n                email: appConfig.email.enabled ? 'configured' : 'disabled'\n            },\n            \n            // Métricas do sistema de auth\n            auth: require('./src/middleware/auth.middleware').getAuthHealth(),\n            \n            // Logs health\n            logging: require('./src/utils/logger').getLoggerHealth()\n        };\n        \n        res.json(health);\n    } catch (error) {\n        systemLogger.error('Health check failed', { error: error.message });\n        res.status(500).json({\n            status: 'error',\n            error: error.message\n        });\n    }\n});\n\n// ===============================================\n// 9. ERROR HANDLING\n// ===============================================\n\n// Error handler global (deve vir no final)\napp.use((error, req, res, next) => {\n    const logger = createLogger('error').child({ \n        requestId: req.logger?.context?.requestId,\n        userId: req.user?.id,\n        url: req.originalUrl,\n        method: req.method\n    });\n    \n    logger.error('Unhandled error', {\n        error: error.message,\n        stack: error.stack,\n        statusCode: error.statusCode || 500\n    });\n    \n    // Não vazar detalhes do erro em produção\n    const isDev = appConfig.environment.isDevelopment;\n    \n    res.status(error.statusCode || 500).json({\n        error: isDev ? error.message : 'Erro interno do servidor',\n        code: error.code || 'INTERNAL_ERROR',\n        ...(isDev && { stack: error.stack })\n    });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n    const logger = createLogger('404').child({ \n        ip: req.ip,\n        url: req.originalUrl\n    });\n    \n    logger.warn('Route not found', {\n        url: req.originalUrl,\n        method: req.method,\n        userAgent: req.get('User-Agent')\n    });\n    \n    res.status(404).json({\n        error: 'Rota não encontrada',\n        code: 'NOT_FOUND'\n    });\n});\n\n// ===============================================\n// 10. GRACEFUL SHUTDOWN\n// ===============================================\n\nprocess.on('SIGTERM', () => {\n    systemLogger.info('SIGTERM received, shutting down gracefully');\n    \n    server.close(() => {\n        systemLogger.info('Process terminated');\n        process.exit(0);\n    });\n});\n\nprocess.on('SIGINT', () => {\n    systemLogger.info('SIGINT received, shutting down gracefully');\n    \n    server.close(() => {\n        systemLogger.info('Process terminated');\n        process.exit(0);\n    });\n});\n\n// ===============================================\n// 11. STARTUP\n// ===============================================\n\nconst server = app.listen(appConfig.environment.PORT, appConfig.environment.HOST, () => {\n    systemLogger.info('Server started successfully', {\n        port: appConfig.environment.PORT,\n        host: appConfig.environment.HOST,\n        environment: appConfig.environment.NODE_ENV,\n        pid: process.pid\n    });\n    \n    // Log de configurações importantes\n    systemLogger.info('Configuration loaded', {\n        database: `${appConfig.database.postgres.host}:${appConfig.database.postgres.port}`,\n        redis: appConfig.database.redis.enabled,\n        oauth: appConfig.oauth.google.enabled,\n        email: appConfig.email.enabled,\n        features: Object.keys(appConfig.features).filter(f => appConfig.features[f])\n    });\n});\n\n// ===============================================\n// 12. EXEMPLOS DE LOGGING ESTRUTURADO\n// ===============================================\n\n// Criar loggers especializados\nconst planLogger = createLogger('plans');\nconst scheduleLogger = createLogger('schedules');\nconst statsLogger = createLogger('statistics');\n\n// Exemplos de uso:\n// planLogger.info('Plan created', { planId: 123, userId: 456 });\n// scheduleLogger.warn('Schedule generation took too long', { duration: 5000 });\n// statsLogger.debug('Cache hit', { key: 'user_stats:123' });\n\n// ===============================================\n// 13. MÉTRICAS E MONITORAMENTO\n// ===============================================\n\n// Endpoint para métricas (apenas admin)\napp.get('/api/admin/metrics', requireAdmin, (req, res) => {\n    const metrics = {\n        uptime: process.uptime(),\n        memory: process.memoryUsage(),\n        cpu: process.cpuUsage(),\n        \n        // Métricas do sistema de auth\n        auth: require('./src/middleware/auth.middleware').getAuthHealth(),\n        \n        // Métricas dos logs\n        logging: require('./src/utils/logger').getLoggerHealth(),\n        \n        // Adicionar suas métricas específicas aqui\n        plans: {\n            total: 0, // implementar\n            active: 0 // implementar\n        }\n    };\n    \n    res.json(metrics);\n});\n\n/* \n * ===============================================\n * RESUMO DOS BENEFÍCIOS IMPLEMENTADOS:\n * ===============================================\n * \n * ✅ Logging estruturado com contexto de requisição\n * ✅ Autenticação robusta com blacklist de tokens\n * ✅ Validação avançada com sanitização\n * ✅ Rate limiting inteligente por usuário\n * ✅ Detecção de padrões maliciosos\n * ✅ Health checks completos\n * ✅ Error handling padronizado\n * ✅ Graceful shutdown\n * ✅ Métricas de sistema\n * ✅ Configuração centralizada\n * ✅ Compatibilidade com código existente\n */