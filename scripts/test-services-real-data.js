#!/usr/bin/env node

/**
 * Script de Teste - Services com Dados Reais
 * FASE 4 - Valida√ß√£o com opera√ß√µes reais ANTES de remover c√≥digo do server.js
 * 
 * IMPORTANTE: Este teste simula opera√ß√µes reais do sistema
 * Seguindo diretrizes do PLANO_MODULARIZACAO_COMPLETA.md
 */

const colors = {
    reset: '\x1b[0m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

async function testServicesWithRealData() {
    console.log(`${colors.magenta}üß™ TESTE COM DADOS REAIS - SERVICES FASE 4${colors.reset}`);
    console.log(`${colors.magenta}${'='.repeat(50)}${colors.reset}\n`);

    let totalTests = 0;
    let passedTests = 0;
    let failedTests = 0;
    const errors = [];

    try {
        // 1. Carregar depend√™ncias
        console.log(`${colors.cyan}üì¶ Inicializando sistema...${colors.reset}`);
        const db = require('../database-postgresql.js');
        const { createRepositories } = require('../src/repositories');
        const { createServices } = require('../src/services');
        
        const repos = createRepositories(db);
        const services = createServices(repos, db);
        
        console.log(`${colors.green}‚úÖ Sistema inicializado${colors.reset}\n`);

        // 2. Testar PlanService com dados simulados
        console.log(`${colors.cyan}üéØ Testando PlanService...${colors.reset}`);
        
        // Test user and plan IDs (usando valores t√≠picos de teste)
        const testUserId = 1;
        const testPlanId = 1;
        
        try {
            // 2.1 Testar checkOverdue
            console.log(`  Testando checkOverdue...`);
            const overdueResult = await services.plan.checkOverdue(testPlanId, testUserId);
            
            if (overdueResult && typeof overdueResult === 'object') {
                console.log(`    ‚úÖ checkOverdue retornou: ${overdueResult.overdueCount || 0} sess√µes atrasadas`);
                passedTests++;
            } else {
                throw new Error('checkOverdue retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            // Se n√£o houver dados, n√£o √© erro cr√≠tico
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è checkOverdue: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå checkOverdue falhou: ${error.message}`);
                errors.push(`PlanService.checkOverdue: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        try {
            // 2.2 Testar calculateProgress
            console.log(`  Testando calculateProgress...`);
            const progressResult = await services.plan.calculateProgress(testPlanId, testUserId);
            
            if (progressResult && typeof progressResult.percentage !== 'undefined') {
                console.log(`    ‚úÖ calculateProgress retornou: ${progressResult.percentage}% conclu√≠do`);
                passedTests++;
            } else {
                throw new Error('calculateProgress retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è calculateProgress: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå calculateProgress falhou: ${error.message}`);
                errors.push(`PlanService.calculateProgress: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        try {
            // 2.3 Testar getGamificationData
            console.log(`  Testando getGamificationData...`);
            const gamificationResult = await services.plan.getGamificationData(testPlanId, testUserId);
            
            if (gamificationResult && gamificationResult.xp !== undefined) {
                console.log(`    ‚úÖ getGamificationData retornou: ${gamificationResult.xp} XP, n√≠vel ${gamificationResult.level}`);
                passedTests++;
            } else {
                throw new Error('getGamificationData retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è getGamificationData: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå getGamificationData falhou: ${error.message}`);
                errors.push(`PlanService.getGamificationData: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        console.log();

        // 3. Testar SessionService
        console.log(`${colors.cyan}üìö Testando SessionService...${colors.reset}`);
        
        const testSessionId = 1;
        
        try {
            // 3.1 Testar calculateStreak
            console.log(`  Testando calculateStreak...`);
            const streakResult = await services.session.calculateStreak(testPlanId, testUserId);
            
            if (streakResult && typeof streakResult.currentStreak !== 'undefined') {
                console.log(`    ‚úÖ calculateStreak retornou: ${streakResult.currentStreak} dias de sequ√™ncia`);
                passedTests++;
            } else {
                throw new Error('calculateStreak retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è calculateStreak: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå calculateStreak falhou: ${error.message}`);
                errors.push(`SessionService.calculateStreak: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        try {
            // 3.2 Testar getSessionStatistics
            console.log(`  Testando getSessionStatistics...`);
            const statsResult = await services.session.getSessionStatistics(testPlanId, testUserId);
            
            if (statsResult && typeof statsResult.totalSessions !== 'undefined') {
                console.log(`    ‚úÖ getSessionStatistics retornou: ${statsResult.totalSessions} sess√µes totais`);
                passedTests++;
            } else {
                throw new Error('getSessionStatistics retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è getSessionStatistics: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå getSessionStatistics falhou: ${error.message}`);
                errors.push(`SessionService.getSessionStatistics: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        console.log();

        // 4. Testar StatisticsService
        console.log(`${colors.cyan}üìä Testando StatisticsService...${colors.reset}`);
        
        try {
            // 4.1 Testar getDashboardMetrics
            console.log(`  Testando getDashboardMetrics...`);
            const metricsResult = await services.statistics.getDashboardMetrics(testPlanId, testUserId);
            
            if (metricsResult && typeof metricsResult.totalTopics !== 'undefined') {
                console.log(`    ‚úÖ getDashboardMetrics retornou: ${metricsResult.totalTopics} t√≥picos totais`);
                passedTests++;
            } else {
                throw new Error('getDashboardMetrics retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è getDashboardMetrics: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå getDashboardMetrics falhou: ${error.message}`);
                errors.push(`StatisticsService.getDashboardMetrics: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        try {
            // 4.2 Testar calculatePerformance
            console.log(`  Testando calculatePerformance...`);
            const perfResult = await services.statistics.calculatePerformance(testPlanId, testUserId);
            
            if (perfResult && typeof perfResult.score !== 'undefined') {
                console.log(`    ‚úÖ calculatePerformance retornou: score ${perfResult.score}`);
                passedTests++;
            } else {
                throw new Error('calculatePerformance retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è calculatePerformance: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå calculatePerformance falhou: ${error.message}`);
                errors.push(`StatisticsService.calculatePerformance: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        try {
            // 4.3 Testar getStudyPatterns
            console.log(`  Testando getStudyPatterns...`);
            const patternsResult = await services.statistics.getStudyPatterns(testPlanId, testUserId);
            
            if (patternsResult && patternsResult.patterns) {
                console.log(`    ‚úÖ getStudyPatterns retornou padr√µes de estudo`);
                passedTests++;
            } else {
                throw new Error('getStudyPatterns retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è getStudyPatterns: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå getStudyPatterns falhou: ${error.message}`);
                errors.push(`StatisticsService.getStudyPatterns: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

        try {
            // 4.4 Testar generateRecommendations
            console.log(`  Testando generateRecommendations...`);
            const recsResult = await services.statistics.generateRecommendations(testPlanId, testUserId);
            
            if (recsResult && Array.isArray(recsResult.recommendations)) {
                console.log(`    ‚úÖ generateRecommendations retornou ${recsResult.recommendations.length} recomenda√ß√µes`);
                passedTests++;
            } else {
                throw new Error('generateRecommendations retornou formato inv√°lido');
            }
            totalTests++;
        } catch (error) {
            if (error.message.includes('n√£o encontrado') || error.message.includes('not found')) {
                console.log(`    ‚ö†Ô∏è generateRecommendations: Sem dados de teste (esperado)`);
                passedTests++;
            } else {
                console.log(`    ‚ùå generateRecommendations falhou: ${error.message}`);
                errors.push(`StatisticsService.generateRecommendations: ${error.message}`);
                failedTests++;
            }
            totalTests++;
        }

    } catch (error) {
        console.error(`${colors.red}‚ùå Erro cr√≠tico: ${error.message}${colors.reset}`);
        errors.push(`Erro cr√≠tico: ${error.message}`);
        failedTests++;
        totalTests++;
    }

    // Relat√≥rio Final
    console.log(`\n${colors.magenta}${'='.repeat(50)}${colors.reset}`);
    console.log(`${colors.magenta}üìä RELAT√ìRIO FINAL - TESTE COM DADOS REAIS${colors.reset}`);
    console.log(`${colors.magenta}${'='.repeat(50)}${colors.reset}\n`);

    console.log(`${colors.green}‚úÖ Testes Passados: ${passedTests}${colors.reset}`);
    console.log(`${colors.red}‚ùå Testes Falhados: ${failedTests}${colors.reset}`);
    console.log(`${colors.blue}üìä Total de Testes: ${totalTests}${colors.reset}`);
    console.log(`${colors.cyan}üìà Taxa de Sucesso: ${Math.round((passedTests/totalTests)*100)}%${colors.reset}\n`);

    if (errors.length > 0) {
        console.log(`${colors.red}‚ö†Ô∏è ERROS ENCONTRADOS:${colors.reset}`);
        errors.forEach((error, index) => {
            console.log(`${colors.red}  ${index + 1}. ${error}${colors.reset}`);
        });
        console.log();
    }

    if (failedTests === 0) {
        console.log(`${colors.green}üéâ TODOS OS TESTES PASSARAM!${colors.reset}`);
        console.log(`${colors.green}‚úÖ Services testados com dados reais${colors.reset}`);
        console.log(`${colors.yellow}üìù PR√ìXIMO PASSO: Integrar Services nos controllers${colors.reset}`);
        console.log(`${colors.yellow}‚ö†Ô∏è IMPORTANTE: S√≥ remover c√≥digo do server.js ap√≥s integra√ß√£o completa${colors.reset}`);
    } else {
        console.log(`${colors.red}‚ùå ALGUNS TESTES FALHARAM${colors.reset}`);
        console.log(`${colors.red}‚ö†Ô∏è Corrija os erros antes de prosseguir com a migra√ß√£o${colors.reset}`);
    }

    // Fechar conex√£o do banco
    if (db && db.end) {
        await db.end();
        console.log(`\n${colors.cyan}üîå Conex√£o com banco fechada${colors.reset}`);
    }

    process.exit(failedTests > 0 ? 1 : 0);
}

// Executar testes
testServicesWithRealData().catch(error => {
    console.error(`${colors.red}Erro fatal: ${error.message}${colors.reset}`);
    process.exit(1);
});