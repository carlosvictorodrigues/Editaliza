# =========================================
# EDITALIZA - DOCKERFILE PRODU√á√ÉO OTIMIZADO
# DigitalOcean & Better-SQLite3 Compatible
# =========================================

# Argumentos de build
ARG NODE_VERSION=20-bullseye
ARG APP_USER=editaliza
ARG APP_UID=1001
ARG APP_GID=1001
ARG DOCKER_BUILD=false

# =========================================
# STAGE 1: BASE SYSTEM
# =========================================
FROM node:${NODE_VERSION} AS base

# Labels para metadados
LABEL stage="base"
LABEL maintainer="Editaliza Team"
LABEL description="Base system with build tools"

# Instalar depend√™ncias do sistema necess√°rias para better-sqlite3
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    make \
    g++ \
    gcc \
    libc6-dev \
    sqlite3 \
    libsqlite3-dev \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# =========================================
# STAGE 2: DEPENDENCIES
# =========================================
FROM base AS deps

# Argumentos no deps
ARG APP_USER
ARG APP_UID  
ARG APP_GID

WORKDIR /app

# Criar usu√°rio n√£o-root
RUN groupadd -g ${APP_GID} ${APP_USER} && \
    useradd -r -u ${APP_UID} -g ${APP_USER} ${APP_USER}

# Copiar arquivos de depend√™ncias
COPY package*.json ./

# Configurar vari√°veis de ambiente para build
ENV NODE_ENV=production
ENV DOCKER_BUILD=true
ENV HUSKY=0
ENV CI=true

# Instalar depend√™ncias de produ√ß√£o com rebuild para better-sqlite3
RUN npm ci --omit=dev --ignore-scripts && \
    npm rebuild better-sqlite3 --build-from-source && \
    npm cache clean --force

# Verificar instala√ß√£o do better-sqlite3
RUN node -e "try { require('better-sqlite3'); console.log('‚úÖ better-sqlite3 OK'); } catch(e) { console.error('‚ùå better-sqlite3 ERROR:', e.message); process.exit(1); }"

# =========================================  
# STAGE 3: BUILD
# =========================================
FROM base AS build

# Argumentos no build
ARG APP_USER
ARG APP_UID
ARG APP_GID

WORKDIR /app

# Criar usu√°rio n√£o-root
RUN groupadd -g ${APP_GID} ${APP_USER} && \
    useradd -r -u ${APP_UID} -g ${APP_USER} ${APP_USER}

# Copiar depend√™ncias do stage anterior
COPY --from=deps --chown=${APP_USER}:${APP_USER} /app/node_modules ./node_modules
COPY --from=deps --chown=${APP_USER}:${APP_USER} /app/package*.json ./

# Copiar c√≥digo fonte
COPY --chown=${APP_USER}:${APP_USER} . .

# Configurar vari√°veis de ambiente
ENV NODE_ENV=production
ENV DOCKER_BUILD=true

# Criar diret√≥rios necess√°rios
RUN mkdir -p uploads logs data && \
    chown -R ${APP_USER}:${APP_USER} uploads logs data && \
    chmod 755 uploads logs data

# Executar verifica√ß√µes p√≥s-build
RUN npm run env:check

# =========================================
# STAGE 4: RUNNER (FINAL)
# =========================================
FROM node:${NODE_VERSION}-slim AS runner

# Labels completos para produ√ß√£o
LABEL org.opencontainers.image.title="Editaliza"
LABEL org.opencontainers.image.description="Sistema inteligente de cronograma de estudos - Produ√ß√£o"
LABEL org.opencontainers.image.version="1.0.0"
LABEL org.opencontainers.image.vendor="Editaliza Team"
LABEL org.opencontainers.image.licenses="MIT"
LABEL org.opencontainers.image.source="https://github.com/editaliza/editaliza"

# Argumentos no runner
ARG APP_USER
ARG APP_UID
ARG APP_GID

# Instalar apenas depend√™ncias m√≠nimas de runtime
RUN apt-get update && apt-get install -y \
    sqlite3 \
    dumb-init \
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# Criar usu√°rio n√£o-root
RUN groupadd -g ${APP_GID} ${APP_USER} && \
    useradd -r -u ${APP_UID} -g ${APP_USER} ${APP_USER}

WORKDIR /app

# Copiar aplica√ß√£o completa do build stage
COPY --from=build --chown=${APP_USER}:${APP_USER} /app ./

# Criar diret√≥rios de dados se n√£o existirem
RUN mkdir -p uploads logs data && \
    chown -R ${APP_USER}:${APP_USER} uploads logs data && \
    chmod 755 uploads logs data

# Configurar vari√°veis de ambiente para produ√ß√£o
ENV NODE_ENV=production
ENV PORT=3000
ENV HOST=0.0.0.0
ENV DOCKER_BUILD=true
ENV HUSKY=0

# Expor porta
EXPOSE ${PORT}

# Volumes para dados persistentes
VOLUME ["/app/uploads", "/app/logs", "/app/data"]

# Healthcheck otimizado
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD node -e "require('http').get('http://localhost:${PORT}/health', (res) => { \
        process.exit(res.statusCode === 200 ? 0 : 1) \
    }).on('error', () => process.exit(1))"

# Mudar para usu√°rio n√£o-root
USER ${APP_USER}

# Verifica√ß√£o final
RUN node -e "console.log('üöÄ Production build ready'); console.log('Node version:', process.version); console.log('Platform:', process.platform); console.log('Arch:', process.arch);"

# Ponto de entrada com dumb-init para signal handling
ENTRYPOINT ["/usr/bin/dumb-init", "--"]

# Comando padr√£o
CMD ["npm", "run", "start:prod"]

# =========================================
# INSTRU√á√ïES DE BUILD E DEPLOY
# =========================================
# Build para produ√ß√£o:
# docker build -f Dockerfile.prod -t editaliza:prod .
#
# Build com argumentos:
# docker build -f Dockerfile.prod --build-arg NODE_VERSION=20-bullseye -t editaliza:prod .
#
# Run localmente:
# docker run -d -p 3000:3000 --name editaliza-prod -e NODE_ENV=production editaliza:prod
#
# Deploy na DigitalOcean:
# 1. Build: npm run docker:build:prod
# 2. Tag: docker tag editaliza:prod registry.digitalocean.com/your-registry/editaliza:latest
# 3. Push: docker push registry.digitalocean.com/your-registry/editaliza:latest
# =========================================