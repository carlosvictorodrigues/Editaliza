/**\n * Controller de Autenticação\n * Contém toda a lógica de negócio para autenticação\n * \n * RESPONSABILIDADES:\n * - Processamento de login/register\n * - Validação de credenciais\n * - Gerenciamento de sessões\n * - Integração com provedores OAuth\n * - Reset de senhas\n * - Validação de segurança\n * - Auditoria e logging\n */\n\nconst bcrypt = require('bcryptjs');\nconst crypto = require('crypto');\nconst jwt = require('jsonwebtoken');\n\n// Importações internas\nconst { authLogger, securityLogger, dbLogger } = require('../utils/logger');\nconst { \n    generateToken, \n    generateRefreshToken, \n    invalidateToken, \n    createSession,\n    validateToken,\n    sessionManager\n} = require('../middleware/auth.middleware');\nconst appConfig = require('../config/app.config');\n// const emailService = require('../services/email.service');\n// const db = require('../services/database.service');\n\n// === HELPERS PRIVADOS ===\n\n/**\n * Hash de senha com salt\n */\nasync function hashPassword(password) {\n    const saltRounds = appConfig.security.bcrypt.rounds;\n    return bcrypt.hash(password, saltRounds);\n}\n\n/**\n * Verificar senha contra hash\n */\nasync function verifyPassword(password, hash) {\n    return bcrypt.compare(password, hash);\n}\n\n/**\n * Gerar token seguro para reset de senha\n */\nfunction generateSecureToken(length = 32) {\n    return crypto.randomBytes(length).toString('hex');\n}\n\n/**\n * Sanitizar dados do usuário para resposta\n */\nfunction sanitizeUser(user) {\n    const {\n        password_hash,\n        password,\n        reset_token,\n        ...safeUser\n    } = user;\n    \n    return safeUser;\n}\n\n/**\n * Criar resposta padrão de autenticação\n */\nfunction createAuthResponse(user, tokens) {\n    return {\n        success: true,\n        message: 'Autenticação realizada com sucesso',\n        user: sanitizeUser(user),\n        tokens: {\n            accessToken: tokens.accessToken,\n            refreshToken: tokens.refreshToken,\n            tokenType: 'Bearer',\n            expiresIn: appConfig.security.jwt.expiresIn,\n            expiresAt: new Date(Date.now() + (15 * 60 * 1000)).toISOString() // 15 min\n        }\n    };\n}\n\n/**\n * Definir cookies de autenticação\n */\nfunction setAuthCookies(res, accessToken, refreshToken) {\n    const cookieOptions = {\n        httpOnly: true,\n        secure: appConfig.security.session.cookie.secure,\n        sameSite: appConfig.security.session.cookie.sameSite,\n        domain: appConfig.security.session.cookie.domain\n    };\n    \n    // Access token (15 minutos)\n    res.cookie('authToken', accessToken, {\n        ...cookieOptions,\n        maxAge: 15 * 60 * 1000\n    });\n    \n    // Refresh token (7 dias)\n    res.cookie('refreshToken', refreshToken, {\n        ...cookieOptions,\n        maxAge: 7 * 24 * 60 * 60 * 1000\n    });\n}\n\n/**\n * Limpar cookies de autenticação\n */\nfunction clearAuthCookies(res) {\n    res.clearCookie('authToken');\n    res.clearCookie('refreshToken');\n}\n\n// === CONTROLLER PRINCIPAL ===\n\nclass AuthController {\n    constructor() {\n        this.logger = authLogger;\n    }\n\n    /**\n     * Registrar novo usuário\n     */\n    async register(req, res) {\n        const logger = this.logger.child({ \n            requestId: req.logger?.context?.requestId,\n            ip: req.ip,\n            method: 'register'\n        });\n        \n        try {\n            const { email, password, name, acceptTerms } = req.body;\n            \n            logger.info('User registration attempt started', { email });\n\n            // Verificar se termos foram aceitos\n            if (!acceptTerms) {\n                return res.status(400).json({\n                    success: false,\n                    error: 'É necessário aceitar os termos de uso',\n                    code: 'TERMS_NOT_ACCEPTED'\n                });\n            }\n            \n            // TODO: Verificar se email já existe\n            // const existingUser = await db.findUserByEmail(email);\n            // if (existingUser) {\n            //     logger.security('registration_duplicate_email', { email });\n            //     return res.status(409).json({\n            //         success: false,\n            //         error: 'Este email já está em uso',\n            //         code: 'EMAIL_ALREADY_EXISTS'\n            //     });\n            // }\n            \n            // Hash da senha\n            const passwordHash = await hashPassword(password);\n            \n            // Gerar token de verificação de email\n            const emailVerificationToken = generateSecureToken();\n            \n            // TODO: Criar usuário no banco\n            // const newUser = await db.createUser({\n            //     email,\n            //     password_hash: passwordHash,\n            //     name: name || null,\n            //     role: 'user',\n            //     email_verification_token: emailVerificationToken,\n            //     email_verified: false,\n            //     terms_accepted_at: new Date(),\n            //     created_at: new Date()\n            // });\n            \n            // Simulação temporária (remover quando implementar DB)\n            const newUser = {\n                id: Date.now(),\n                email,\n                name: name || null,\n                role: 'user',\n                email_verified: false,\n                terms_accepted_at: new Date(),\n                created_at: new Date()\n            };\n            \n            // Criar sessão\n            const sessionId = createSession(newUser.id);\n            \n            // Gerar tokens JWT\n            const accessToken = generateToken({\n                id: newUser.id,\n                email: newUser.email,\n                role: newUser.role,\n                sessionId,\n                email_verified: newUser.email_verified\n            });\n            \n            const refreshToken = generateRefreshToken({\n                id: newUser.id,\n                sessionId\n            });\n            \n            // TODO: Salvar refresh token no banco\n            // await db.saveRefreshToken({\n            //     user_id: newUser.id,\n            //     token_hash: crypto.createHash('sha256').update(refreshToken).digest('hex'),\n            //     expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 dias\n            //     created_at: new Date()\n            // });\n            \n            // TODO: Enviar email de verificação se configurado\n            // if (appConfig.features.emailVerification && appConfig.email.enabled) {\n            //     await emailService.sendVerificationEmail(email, emailVerificationToken);\n            // }\n            \n            // Definir cookies\n            setAuthCookies(res, accessToken, refreshToken);\n            \n            logger.info('User registration completed successfully', { \n                userId: newUser.id,\n                email: newUser.email\n            });\n            \n            // Log de segurança para auditoria\n            securityLogger.info('new_user_registered', {\n                userId: newUser.id,\n                email: newUser.email,\n                ip: req.ip,\n                userAgent: req.get('User-Agent')\n            });\n            \n            res.status(201).json(createAuthResponse(newUser, {\n                accessToken,\n                refreshToken\n            }));\n            \n        } catch (error) {\n            logger.error('Registration process failed', {\n                error: error.message,\n                stack: error.stack,\n                email: req.body.email\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor. Tente novamente mais tarde.',\n                code: 'REGISTRATION_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Login de usuário\n     */\n    async login(req, res) {\n        const logger = this.logger.child({ \n            requestId: req.logger?.context?.requestId,\n            ip: req.ip,\n            method: 'login'\n        });\n        \n        try {\n            const { email, password, rememberMe = false } = req.body;\n            \n            logger.info('User login attempt started', { email });\n            \n            // TODO: Buscar usuário no banco\n            // const user = await db.findUserByEmail(email);\n            \n            // Simulação temporária (remover quando implementar DB)\n            const user = null;\n            \n            if (!user) {\n                // Log de tentativa com email inválido\n                securityLogger.warn('login_attempt_invalid_email', {\n                    email,\n                    ip: req.ip,\n                    userAgent: req.get('User-Agent')\n                });\n                \n                // Delay para prevenir timing attacks\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                \n                return res.status(401).json({\n                    success: false,\n                    error: 'Email ou senha incorretos',\n                    code: 'INVALID_CREDENTIALS'\n                });\n            }\n            \n            // Verificar se conta está ativa\n            if (user.status === 'suspended' || user.status === 'banned') {\n                securityLogger.warn('login_attempt_suspended_account', {\n                    userId: user.id,\n                    email: user.email,\n                    status: user.status,\n                    ip: req.ip\n                });\n                \n                return res.status(403).json({\n                    success: false,\n                    error: 'Conta temporariamente suspensa. Entre em contato com o suporte.',\n                    code: 'ACCOUNT_SUSPENDED'\n                });\n            }\n            \n            // Verificar senha\n            const isValidPassword = await verifyPassword(password, user.password_hash);\n            \n            if (!isValidPassword) {\n                securityLogger.warn('login_attempt_invalid_password', {\n                    userId: user.id,\n                    email: user.email,\n                    ip: req.ip,\n                    userAgent: req.get('User-Agent')\n                });\n                \n                // TODO: Incrementar contador de tentativas falhadas\n                // await db.incrementFailedLoginAttempts(user.id);\n                \n                // Delay para prevenir brute force\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                \n                return res.status(401).json({\n                    success: false,\n                    error: 'Email ou senha incorretos',\n                    code: 'INVALID_CREDENTIALS'\n                });\n            }\n            \n            // TODO: Resetar contador de tentativas falhadas\n            // await db.resetFailedLoginAttempts(user.id);\n            \n            // Verificar se email foi verificado (se obrigatório)\n            if (appConfig.features.emailVerification && !user.email_verified) {\n                return res.status(403).json({\n                    success: false,\n                    error: 'Email não verificado. Verifique sua caixa de entrada.',\n                    code: 'EMAIL_NOT_VERIFIED',\n                    actions: {\n                        resendVerification: true\n                    }\n                });\n            }\n            \n            // Criar nova sessão\n            const sessionId = createSession(user.id);\n            \n            // Gerar tokens\n            const tokenExpiry = rememberMe ? '30d' : appConfig.security.jwt.expiresIn;\n            \n            const accessToken = generateToken({\n                id: user.id,\n                email: user.email,\n                role: user.role,\n                sessionId,\n                email_verified: user.email_verified\n            }, {\n                expiresIn: tokenExpiry\n            });\n            \n            const refreshToken = generateRefreshToken({\n                id: user.id,\n                sessionId\n            });\n            \n            // TODO: Salvar refresh token e atualizar último login\n            // await Promise.all([\n            //     db.saveRefreshToken({\n            //         user_id: user.id,\n            //         token_hash: crypto.createHash('sha256').update(refreshToken).digest('hex'),\n            //         expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n            //         created_at: new Date()\n            //     }),\n            //     db.updateLastLogin(user.id, req.ip, req.get('User-Agent'))\n            // ]);\n            \n            // Definir cookies\n            setAuthCookies(res, accessToken, refreshToken);\n            \n            logger.info('User login completed successfully', { \n                userId: user.id,\n                email: user.email,\n                rememberMe\n            });\n            \n            // Log de segurança\n            securityLogger.info('successful_login', {\n                userId: user.id,\n                email: user.email,\n                ip: req.ip,\n                userAgent: req.get('User-Agent'),\n                sessionId\n            });\n            \n            res.json(createAuthResponse(user, {\n                accessToken,\n                refreshToken\n            }));\n            \n        } catch (error) {\n            logger.error('Login process failed', {\n                error: error.message,\n                stack: error.stack,\n                email: req.body.email\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor. Tente novamente mais tarde.',\n                code: 'LOGIN_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Logout de usuário\n     */\n    async logout(req, res) {\n        const logger = this.logger.child({ \n            requestId: req.logger?.context?.requestId,\n            userId: req.user.id,\n            method: 'logout'\n        });\n        \n        try {\n            const userId = req.user.id;\n            const sessionId = req.user.sessionId;\n            \n            logger.info('User logout started', { userId });\n            \n            // Invalidar token atual\n            const authHeader = req.headers.authorization;\n            const token = authHeader?.split(' ')[1] || req.cookies?.authToken;\n            \n            if (token) {\n                invalidateToken(token);\n            }\n            \n            // Remover sessão ativa\n            if (sessionId) {\n                sessionManager.removeSession(userId, sessionId);\n            }\n            \n            // TODO: Invalidar todos os refresh tokens do usuário\n            // await db.invalidateUserRefreshTokens(userId);\n            \n            // Limpar cookies\n            clearAuthCookies(res);\n            \n            logger.info('User logout completed successfully', { userId });\n            \n            // Log de segurança\n            securityLogger.info('user_logout', {\n                userId,\n                ip: req.ip,\n                sessionId\n            });\n            \n            res.json({\n                success: true,\n                message: 'Logout realizado com sucesso'\n            });\n            \n        } catch (error) {\n            logger.error('Logout process failed', {\n                error: error.message,\n                stack: error.stack,\n                userId: req.user?.id\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor',\n                code: 'LOGOUT_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Refresh de token de acesso\n     */\n    async refreshToken(req, res) {\n        const logger = this.logger.child({ \n            requestId: req.logger?.context?.requestId,\n            ip: req.ip,\n            method: 'refreshToken'\n        });\n        \n        try {\n            const refreshToken = req.body.refreshToken || req.cookies?.refreshToken;\n            \n            if (!refreshToken) {\n                return res.status(401).json({\n                    success: false,\n                    error: 'Refresh token não fornecido',\n                    code: 'REFRESH_TOKEN_MISSING'\n                });\n            }\n            \n            logger.info('Token refresh attempt started');\n            \n            // Validar refresh token\n            let decoded;\n            try {\n                decoded = await validateToken(refreshToken, appConfig.security.jwt.refreshSecret);\n            } catch (error) {\n                securityLogger.warn('invalid_refresh_token_used', {\n                    error: error.message,\n                    ip: req.ip,\n                    userAgent: req.get('User-Agent')\n                });\n                \n                return res.status(401).json({\n                    success: false,\n                    error: 'Refresh token inválido ou expirado',\n                    code: 'REFRESH_TOKEN_INVALID'\n                });\n            }\n            \n            // TODO: Verificar se refresh token existe no banco e não foi revogado\n            // const tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n            // const dbToken = await db.findRefreshToken(tokenHash);\n            \n            // if (!dbToken || dbToken.revoked || dbToken.expires_at < new Date()) {\n            //     securityLogger.warn('revoked_refresh_token_used', {\n            //         userId: decoded.id,\n            //         ip: req.ip\n            //     });\n            //     \n            //     return res.status(401).json({\n            //         success: false,\n            //         error: 'Refresh token foi revogado',\n            //         code: 'REFRESH_TOKEN_REVOKED'\n            //     });\n            // }\n            \n            // TODO: Buscar dados atualizados do usuário\n            // const user = await db.findUserById(decoded.id);\n            \n            // Simulação temporária\n            const user = {\n                id: decoded.id,\n                email: 'user@example.com',\n                role: 'user',\n                email_verified: true\n            };\n            \n            if (!user) {\n                return res.status(401).json({\n                    success: false,\n                    error: 'Usuário não encontrado',\n                    code: 'USER_NOT_FOUND'\n                });\n            }\n            \n            // Verificar se usuário ainda está ativo\n            if (user.status && user.status !== 'active') {\n                return res.status(403).json({\n                    success: false,\n                    error: 'Conta não está ativa',\n                    code: 'ACCOUNT_INACTIVE'\n                });\n            }\n            \n            // Gerar novo access token\n            const newAccessToken = generateToken({\n                id: user.id,\n                email: user.email,\n                role: user.role,\n                sessionId: decoded.sessionId,\n                email_verified: user.email_verified\n            });\n            \n            // TODO: Rotacionar refresh token periodicamente (opcional)\n            // const shouldRotate = Date.now() - (decoded.iat * 1000) > (24 * 60 * 60 * 1000); // 24h\n            // let newRefreshToken = refreshToken;\n            // if (shouldRotate) {\n            //     newRefreshToken = generateRefreshToken({\n            //         id: user.id,\n            //         sessionId: decoded.sessionId\n            //     });\n            //     await db.revokeRefreshToken(tokenHash);\n            //     await db.saveRefreshToken({\n            //         user_id: user.id,\n            //         token_hash: crypto.createHash('sha256').update(newRefreshToken).digest('hex'),\n            //         expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n            //     });\n            // }\n            \n            logger.info('Token refresh completed successfully', { userId: user.id });\n            \n            res.json({\n                success: true,\n                accessToken: newAccessToken,\n                tokenType: 'Bearer',\n                expiresIn: appConfig.security.jwt.expiresIn,\n                // refreshToken: newRefreshToken // Incluir apenas se rotacionou\n            });\n            \n        } catch (error) {\n            logger.error('Token refresh failed', {\n                error: error.message,\n                stack: error.stack\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor',\n                code: 'REFRESH_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Obter informações do usuário atual\n     */\n    async getCurrentUser(req, res) {\n        try {\n            const userId = req.user.id;\n            \n            // TODO: Buscar dados atualizados do usuário\n            // const user = await db.findUserById(userId);\n            \n            // Simulação temporária (usar dados do token)\n            const user = {\n                id: req.user.id,\n                email: req.user.email,\n                name: null,\n                role: req.user.role,\n                email_verified: req.user.email_verified || false,\n                created_at: new Date(),\n                last_login: new Date()\n            };\n            \n            res.json({\n                success: true,\n                user: sanitizeUser(user)\n            });\n            \n        } catch (error) {\n            this.logger.error('Get current user failed', {\n                error: error.message,\n                userId: req.user?.id\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor',\n                code: 'USER_FETCH_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Solicitar reset de senha\n     */\n    async requestPasswordReset(req, res) {\n        const logger = this.logger.child({ \n            requestId: req.logger?.context?.requestId,\n            ip: req.ip,\n            method: 'requestPasswordReset'\n        });\n        \n        try {\n            const { email } = req.body;\n            \n            logger.info('Password reset request started', { email });\n            \n            // TODO: Verificar se usuário existe\n            // const user = await db.findUserByEmail(email);\n            \n            // Sempre retornar sucesso (security by obscurity)\n            res.json({\n                success: true,\n                message: 'Se o email estiver registrado, você receberá instruções para redefinir sua senha em breve.'\n            });\n            \n            // TODO: Se usuário existir, processar reset\n            // if (user) {\n            //     const resetToken = generateSecureToken(32);\n            //     const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hora\n            //     \n            //     await db.savePasswordResetToken({\n            //         user_id: user.id,\n            //         token: resetToken,\n            //         expires_at: expiresAt,\n            //         created_at: new Date()\n            //     });\n            //     \n            //     if (appConfig.email.enabled) {\n            //         await emailService.sendPasswordResetEmail(email, resetToken);\n            //     }\n            //     \n            //     logger.info('Password reset token generated', {\n            //         userId: user.id,\n            //         email: user.email\n            //     });\n            // }\n            \n        } catch (error) {\n            logger.error('Password reset request failed', {\n                error: error.message,\n                stack: error.stack,\n                email: req.body.email\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor',\n                code: 'PASSWORD_RESET_REQUEST_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Resetar senha com token\n     */\n    async resetPassword(req, res) {\n        const logger = this.logger.child({ \n            requestId: req.logger?.context?.requestId,\n            ip: req.ip,\n            method: 'resetPassword'\n        });\n        \n        try {\n            const { token, newPassword } = req.body;\n            \n            logger.info('Password reset attempt started');\n            \n            // TODO: Verificar token no banco\n            // const resetToken = await db.findPasswordResetToken(token);\n            \n            // if (!resetToken || resetToken.expires_at < new Date() || resetToken.used) {\n            //     logger.warn('Invalid password reset token used', { token: token.substring(0, 8) });\n            //     \n            //     return res.status(400).json({\n            //         success: false,\n            //         error: 'Token inválido ou expirado',\n            //         code: 'INVALID_RESET_TOKEN'\n            //     });\n            // }\n            \n            // Hash da nova senha\n            const newPasswordHash = await hashPassword(newPassword);\n            \n            // TODO: Atualizar senha e marcar token como usado\n            // await Promise.all([\n            //     db.updateUserPassword(resetToken.user_id, newPasswordHash),\n            //     db.markPasswordResetTokenAsUsed(token),\n            //     db.invalidateUserRefreshTokens(resetToken.user_id) // Invalidar todas as sessões\n            // ]);\n            \n            logger.info('Password reset completed successfully');\n            \n            // Log de segurança\n            securityLogger.info('password_reset_completed', {\n                // userId: resetToken.user_id,\n                ip: req.ip,\n                userAgent: req.get('User-Agent')\n            });\n            \n            res.json({\n                success: true,\n                message: 'Senha redefinida com sucesso. Você pode fazer login com a nova senha.'\n            });\n            \n        } catch (error) {\n            logger.error('Password reset failed', {\n                error: error.message,\n                stack: error.stack\n            });\n            \n            res.status(500).json({\n                success: false,\n                error: 'Erro interno do servidor',\n                code: 'PASSWORD_RESET_ERROR'\n            });\n        }\n    }\n\n    /**\n     * Health check do sistema de autenticação\n     */\n    async healthCheck(req, res) {\n        try {\n            const health = {\n                status: 'healthy',\n                timestamp: new Date().toISOString(),\n                uptime: process.uptime(),\n                version: process.env.npm_package_version || '1.0.0',\n                features: {\n                    registration: appConfig.features.registrationOpen,\n                    emailVerification: appConfig.features.emailVerification,\n                    googleOAuth: appConfig.oauth.google.enabled,\n                    passwordReset: appConfig.features.passwordReset\n                },\n                security: {\n                    jwtAlgorithm: appConfig.security.jwt.algorithm,\n                    bcryptRounds: appConfig.security.bcrypt.rounds,\n                    csrfEnabled: appConfig.security.csrf.enabled\n                },\n                sessions: {\n                    activeUsers: sessionManager.activeSessions.size,\n                    // TODO: Adicionar mais métricas de sessão do banco\n                }\n            };\n            \n            res.json(health);\n        } catch (error) {\n            res.status(500).json({\n                status: 'error',\n                error: error.message\n            });\n        }\n    }\n}\n\n// === EXPORTS ===\n\n// Instância singleton do controller\nconst authController = new AuthController();\n\n// Exportar métodos bound\nmodule.exports = {\n    register: authController.register.bind(authController),\n    login: authController.login.bind(authController),\n    logout: authController.logout.bind(authController),\n    refreshToken: authController.refreshToken.bind(authController),\n    getCurrentUser: authController.getCurrentUser.bind(authController),\n    requestPasswordReset: authController.requestPasswordReset.bind(authController),\n    resetPassword: authController.resetPassword.bind(authController),\n    healthCheck: authController.healthCheck.bind(authController),\n    \n    // Exportar classe para testes\n    AuthController\n};