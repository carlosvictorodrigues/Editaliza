// performance_middleware.js - Middleware para monitoramento de performance
const os = require('os');\n\n// Middleware para logging de performance\nconst performanceLogger = (req, res, next) => {\n    const startTime = Date.now();\n    const startMemory = process.memoryUsage();\n    \n    // Override do res.json para capturar o fim da requisição\n    const originalJson = res.json;\n    res.json = function(data) {\n        const endTime = Date.now();\n        const endMemory = process.memoryUsage();\n        const duration = endTime - startTime;\n        \n        // Log estruturado de performance\n        const perfLog = {\n            timestamp: new Date().toISOString(),\n            method: req.method,\n            url: req.url,\n            status: res.statusCode,\n            duration: `${duration}ms`,\n            memory: {\n                rss: `${((endMemory.rss - startMemory.rss) / 1024 / 1024).toFixed(2)}MB`,\n                heapUsed: `${((endMemory.heapUsed - startMemory.heapUsed) / 1024 / 1024).toFixed(2)}MB`\n            },\n            system: {\n                cpuUsage: `${(os.loadavg()[0] * 100).toFixed(1)}%`,\n                freeMemory: `${(os.freemem() / 1024 / 1024 / 1024).toFixed(1)}GB`\n            }\n        };\n        \n        // Log apenas rotas críticas ou requisições lentas\n        if (duration > 1000 || req.url.includes('/generate') || req.url.includes('/replan')) {\n            console.log(`[PERFORMANCE] ${JSON.stringify(perfLog)}`);\n        }\n        \n        // Log de alerta para requisições muito lentas\n        if (duration > 5000) {\n            console.warn(`[SLOW_QUERY] Requisição lenta detectada: ${req.method} ${req.url} - ${duration}ms`);\n        }\n        \n        return originalJson.call(this, data);\n    };\n    \n    next();\n};\n\n// Middleware para rate limiting baseado em performance\nconst performanceBasedRateLimit = (req, res, next) => {\n    const cpuUsage = os.loadavg()[0];\n    const freeMemory = os.freemem() / os.totalmem();\n    \n    // Se CPU ou memória estão sob alta carga, aplicar rate limit mais restritivo\n    if (cpuUsage > 0.8 || freeMemory < 0.1) {\n        console.warn(`[SYSTEM_LOAD] Alta carga do sistema detectada - CPU: ${(cpuUsage * 100).toFixed(1)}%, Mem livre: ${(freeMemory * 100).toFixed(1)}%`);\n        \n        // Aplicar delay para requisições não críticas\n        if (!req.url.includes('/login') && !req.url.includes('/logout')) {\n            return setTimeout(() => next(), 100);\n        }\n    }\n    \n    next();\n};\n\n// Middleware para análise de queries lentas do banco\nconst queryAnalyzer = {\n    slowQueries: new Map(),\n    \n    logSlowQuery: (query, duration, params = []) => {\n        if (duration > 100) { // Queries mais lentas que 100ms\n            const queryKey = query.substring(0, 100); // Primeiros 100 chars como chave\n            \n            if (!queryAnalyzer.slowQueries.has(queryKey)) {\n                queryAnalyzer.slowQueries.set(queryKey, {\n                    query: queryKey,\n                    count: 0,\n                    totalTime: 0,\n                    avgTime: 0,\n                    maxTime: 0,\n                    lastSeen: new Date()\n                });\n            }\n            \n            const stats = queryAnalyzer.slowQueries.get(queryKey);\n            stats.count++;\n            stats.totalTime += duration;\n            stats.avgTime = stats.totalTime / stats.count;\n            stats.maxTime = Math.max(stats.maxTime, duration);\n            stats.lastSeen = new Date();\n            \n            console.warn(`[SLOW_QUERY] ${duration}ms - ${query.substring(0, 200)}...`);\n        }\n    },\n    \n    getReport: () => {\n        const report = Array.from(queryAnalyzer.slowQueries.values())\n            .sort((a, b) => b.avgTime - a.avgTime)\n            .slice(0, 10); // Top 10 queries mais lentas\n            \n        return {\n            timestamp: new Date().toISOString(),\n            topSlowQueries: report\n        };\n    },\n    \n    reset: () => {\n        queryAnalyzer.slowQueries.clear();\n    }\n};\n\n// Wrapper para dbGet, dbAll, dbRun com monitoramento\nconst createMonitoredDbFunction = (originalFn, fnName) => {\n    return async (sql, params) => {\n        const startTime = Date.now();\n        try {\n            const result = await originalFn(sql, params);\n            const duration = Date.now() - startTime;\n            \n            // Log queries lentas\n            queryAnalyzer.logSlowQuery(sql, duration, params);\n            \n            return result;\n        } catch (error) {\n            const duration = Date.now() - startTime;\n            console.error(`[DB_ERROR] ${fnName} falhou após ${duration}ms - ${sql}`, error.message);\n            throw error;\n        }\n    };\n};\n\n// Função para relatório de sistema\nconst getSystemReport = () => {\n    const memUsage = process.memoryUsage();\n    const cpuUsage = os.loadavg();\n    \n    return {\n        timestamp: new Date().toISOString(),\n        system: {\n            platform: os.platform(),\n            arch: os.arch(),\n            uptime: `${(os.uptime() / 3600).toFixed(1)}h`,\n            cpuLoad: {\n                '1min': `${(cpuUsage[0] * 100).toFixed(1)}%`,\n                '5min': `${(cpuUsage[1] * 100).toFixed(1)}%`,\n                '15min': `${(cpuUsage[2] * 100).toFixed(1)}%`\n            },\n            memory: {\n                total: `${(os.totalmem() / 1024 / 1024 / 1024).toFixed(1)}GB`,\n                free: `${(os.freemem() / 1024 / 1024 / 1024).toFixed(1)}GB`,\n                used: `${((os.totalmem() - os.freemem()) / 1024 / 1024 / 1024).toFixed(1)}GB`\n            }\n        },\n        process: {\n            pid: process.pid,\n            uptime: `${(process.uptime() / 3600).toFixed(1)}h`,\n            memory: {\n                rss: `${(memUsage.rss / 1024 / 1024).toFixed(1)}MB`,\n                heapTotal: `${(memUsage.heapTotal / 1024 / 1024).toFixed(1)}MB`,\n                heapUsed: `${(memUsage.heapUsed / 1024 / 1024).toFixed(1)}MB`,\n                external: `${(memUsage.external / 1024 / 1024).toFixed(1)}MB`\n            }\n        },\n        database: queryAnalyzer.getReport()\n    };\n};\n\n// Função para limpar logs antigos\nconst cleanupOldLogs = () => {\n    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n    \n    for (const [key, stats] of queryAnalyzer.slowQueries) {\n        if (stats.lastSeen < oneDayAgo) {\n            queryAnalyzer.slowQueries.delete(key);\n        }\n    }\n};\n\n// Agendar limpeza a cada hora\nsetInterval(cleanupOldLogs, 60 * 60 * 1000);\n\n// Função para alertas automáticos\nconst checkSystemHealth = () => {\n    const memUsage = process.memoryUsage();\n    const freeMemory = os.freemem() / os.totalmem();\n    const cpuUsage = os.loadavg()[0];\n    \n    // Alertas de memória\n    if (memUsage.heapUsed > 512 * 1024 * 1024) { // 512MB\n        console.warn(`[MEMORY_ALERT] Uso de heap alto: ${(memUsage.heapUsed / 1024 / 1024).toFixed(1)}MB`);\n    }\n    \n    // Alertas de CPU\n    if (cpuUsage > 0.9) {\n        console.warn(`[CPU_ALERT] CPU sob alta carga: ${(cpuUsage * 100).toFixed(1)}%`);\n    }\n    \n    // Alertas de memória do sistema\n    if (freeMemory < 0.1) {\n        console.warn(`[SYSTEM_MEMORY_ALERT] Pouca memória livre no sistema: ${(freeMemory * 100).toFixed(1)}%`);\n    }\n};\n\n// Verificar saúde do sistema a cada 5 minutos\nsetInterval(checkSystemHealth, 5 * 60 * 1000);\n\nmodule.exports = {\n    performanceLogger,\n    performanceBasedRateLimit,\n    queryAnalyzer,\n    createMonitoredDbFunction,\n    getSystemReport,\n    cleanupOldLogs,\n    checkSystemHealth\n};